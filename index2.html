<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>Canvas</title>
    <style>
      body {
        margin: 0;
        overflow: hidden;
        background: #ccc;
      }

      .toolbar {
        width: 150px;
        height: 25px;
        background: #ccc;
        padding: 5px;
      }

      input[type="color"], button {
        width: 90%;
        margin: 0 auto;
        display: block;
      }

      input[type="range"] {
        width: 70%;
      }

       span {
         position: relative;
         bottom: 5px;
       }
    </style>
  </head>
  <body>
    <div class="toolbar">
      <button>Reset</button>
    </div>

    <canvas class="myCanvas">
      <p>Add suitable fallback here.</p>
    </canvas>

    <script>

      const canvas = document.querySelector('.myCanvas');
      const width = canvas.width = "400";
      const height = canvas.height = "400";
      const ctx = canvas.getContext('2d');

      ctx.fillStyle = 'rgb(255,255,255)';
      ctx.fillRect(0,0,width,height);

    //   const colorPicker = document.querySelector('input[type="color"]');
    //   const sizePicker = document.querySelector('input[type="range"]');
    //   const output = document.querySelector('.output');
      const resetBtn = document.querySelector('button');

      // covert degrees to radians
      function degToRad(degrees) {
        return degrees * Math.PI / 180;
      };

      // update sizepicker output value

    //   sizePicker.oninput = function() {
    //     output.textContent = sizePicker.value;
    //   }

      // store mouse pointer coordinates, and whether the button is pressed
      let curX;
      let curY;
      let pressed = false;
      let released = false;
      let cenX;
      let cenY;
      let Radius;

      // update mouse pointer coordinates
      document.onmousemove = function(e) {
        curX = (window.Event) ? e.pageX : e.clientX + (document.documentElement.scrollLeft ? document.documentElement.scrollLeft : document.body.scrollLeft);
        curY = (window.Event) ? e.pageY : e.clientY + (document.documentElement.scrollTop ? document.documentElement.scrollTop : document.body.scrollTop);
      }

      canvas.onmousedown = function(e) {
        console.log('onmousedown');
        pressed = true;
        cenX = (window.Event) ? e.pageX : e.clientX + (document.documentElement.scrollLeft ? document.documentElement.scrollLeft : document.body.scrollLeft);
        cenY = (window.Event) ? e.pageY : e.clientY + (document.documentElement.scrollTop ? document.documentElement.scrollTop : document.body.scrollTop);
      };

      canvas.onmouseup = function() {
        pressed = false;
        released = true;
      }

      function reset(){
        console.log('reset');
        ctx.fillStyle = 'rgb(255,255,255)';
        ctx.fillRect(0,0,width,height);
      }

      resetBtn.onclick = reset()

      function draw_grid(){
        console.log('draw_grid');
        var n = 20;
        var moveOffset = 20;
        ctx.fillStyle = 'rgb(128, 128, 128)';

        for(var i = 0; i < n; i++) {
            for(var j=0; j < n; j++){
                ctx.fillRect(i*moveOffset+10, j*moveOffset+10, 5, 5);
            }
        }
      }
      
      function draw_circle(){
        console.log('draw_circle');
        ctx.fillStyle = 'rgb(255, 0, 0)';
        Radius=Math.sqrt((curX-cenX)**2+(curY-cenY)**2)
        ctx.arc(cenX, cenY, Radius, degToRad(0), degToRad(360), false);
        ctx.stroke();
      }

      

      function draw() {
        if(released) {
            draw_circle();
            released = false;
            console.log('draw');
        }
        requestAnimationFrame(draw);
      }

      ctx.clearRect(0, 0, width, height);
      reset();
      draw_grid();
      draw();
      
    </script>
  </body>
</html>